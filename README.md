<h1 style='color: red;'>ДОКУМЕНТАЦИЯ В РАЗРАБОТКЕ! После полного завершения работы над библиотекой она будет загружена в ветку main!

# Компиляция библиотеки
Откройте терминал в директории библиотеки
``` bash
cd /путь/до/папки
```
Создайте директорию для результатов компиляции
``` bash
mkdir build
cd build
```
Скомпилируйте библиотеку
``` bash
cmake -DDEMO=yes ../
cmake --build ./
```
После этого в этой директории появятся 2 файла `distrand-lib.o` - библиотека и `distrand-demo` - тест библиотеки с расчётом среднего времени выполнения и просмотром распределения для введённых формул. Если не хотите компилировать `distrand-demo` в качестве аргумента cmake выше укажите `-DDEMO=no`
# Функции библиотеки
Для использования библиотеки подключите её к проекту(например, с помощью аргумента -l distrand-lib.o для GCC). Также подключите заголовочный файл библиотеки:
``` c 
#include <distrand.h>
```
## Датчики стандартных псевдослучайных чисел
Функция генерации случайного значения принимает `void*` как аргумент и возвращает `double`. Описывается типом `uniform_t`. 
Для более простого обращения к датчику можно воспользоваться типом `uniform_callable_t`
``` c 
uniform_callable_t uc = {
    .gen = <...>, // Функция генератоции стандартных случайных чисел(uniform_t)
    .arg = <...>  // Аргумент для функции gen
};
uniform_gen(&uc);
```
### Вихрь Мерсенна(Mercene Twister)
``` c
mt19937_t mtrd; // Создаём датчик
mt19937_64_init(&mtrd, clock()); // Инициализируем датчик с сидом clock()
double val = mt19937_64_generate(&mtrd); // Генерируем случайное значение
mt19937_64_free(&mtrd); // Очищаем датчик из памяти после того, как все нужные значения получены
```
### Мультипликативный генератор метода вычетов
``` c
multiplicative_rand_gen_t mrd = multiplicative_rand_gen_create(); // Создаём датчик
double val = multiplicative_rand_gen_generate(&mrd); // Генерируем случайное значение
```
## Подбор параметра
Тип `prob_eq_overflow_t` описывает функцию, принимающую как аргумент подбираемое значение и любую дополнительную информацию, нужную для алгритма подбора параметра. Возвращает `false`, если значение слишком маленькое, иначе - `true`;
Функция подбора параметра принимает `double*` - ссылку на результат с начальным значением, функцию `prob_eq_overflow_t` и аргумент с дополнительной информацией для предыдущего аргумента. Описывается типом `prob_eq_t`.
### Digit By Digit(DBD)
Реализация `prob_eq_t`. Значение подбирается цифра за цифрой. Функция - `dbd_prob_eq`.
## Экономичный алгоритм двустороннего метода исключения(EDSRM)
Описание алгоритма можете найти по ссылке: http://edsrm.andronix1.ru/docs/edsrm-method-description.pdf
### Монотонные плотности распределения на отрезке(mnt)
Тип `edsrm_mnt_cache_segment_t` описывает столбик сетки. Содержит значение мажоранты, миноранты, и краёв столбика по оси `u`.
Тип `edsrm_mnt_pd_info_t` описывает информацию для построения сетки. То есть плотность распределения `pd`, интервал плотности(`a` и `b`) и количество стобиков в сетке `size`.
Тип `edsrm_mnt_cfg_t` описывает полную конфигурацию для инициализации метода. То есть ссылку на информацию для построения сетки(`pd_info` с типом `edsrm_mnt_pd_info_t`) и алгоритм подбора параметра с типом `prob_eq` `prob_eq_t`
Тип `edsrm_mnt_t` содержит в себе полную информацию для работы с монотонными плотностями распределения. Инициализируется с помощью `edsrm_mnt_create` или `edsrm_mnt_from_idu`.

Функция `edsrm_mnt_is_cache_overflow` - функция "переполнения" с типом `prob_eq_overflow_t`
Функция `edsrm_mnt_from_idu` позволяет инициализировать `edsrm_mnt_t` по ссылке с указанием ширины самого высокого столбика и информации для построения сетки.
Функция `edsrm_mnt_create` - обертка над функцией `edsrm_mnt_from_idu` и позволяет инициализировать `edsrm_mnt_t` по ссылке с помощью полную конфигурацию для инициализации метода. Возвращает результат инициализации - `true` / `false`. Сначала идёт подбор параметра, затем он передаётся в `edsrm_mnt_from_idu`
Функция `edsrm_mnt_free` Нужна для отчистки данных метода из памяти. Её надо вызвать если методом больше пользоваться не будут чтобы избежать утечек памяти.
Функция `edsrm_mnt_try_generate` разыгрывает одну точку под мажорантой и если она попала под `f(u)`(см полное описание алгоритма), то результат записывается в переданную по ссылке переменную и возвражает `true`, иначе - `false` без изменения переменной.
Функция `edsrm_mnt_generate` является обёрткой над функцией `edsrm_mnt_try_generate`. Она пытается сгенерировать точку до тех пор, пока не получится и возвращает значение.

Таким образом использование алгоритма выглядит следующим образом:
``` c 
// Инициализируем датчик
multiplicative_rand_gen_t gen = multiplicative_rand_gen_create();
uniform_callable_t uc = {
    .gen = multiplicative_rand_gen_generate,
    .arg = &gen
};

// Инициализируем алгоритм
edsrm_mnt_pd_info_t info = {
    .a = 0,
    .b = pi, 
    .pd = cos, // f(u)=cos(u); 0 < u < pi
    .size = 330 // Размер сетки
};
edsrm_mnt_t cache;
edsrm_mnt_cfg_t cfg = {
    .pd_info = &info,
    .prob_eq = dbd_prob_eq // Подбор параметра "цифра за цифрой"
};
if (!edsrm_mnt_create(&edsrm.cache, &cfg)) {
    printf("Не удалось инициализировать алгоритм\n");
    exit(1);
}
// Используем алгоритм
double res = edsrm_mnt_generate(&cache, &uc); // Генерируем число
// .........

// Очищаем память
edsrm_mnt_free(&cache);
```
### Плотности с двумы отрезками монотонности(2rng)
Является обёрткой над `edsrm_mnt_t`. Алгоритм разбивает плотность на 2 отрезка монотонности и сначала выбирает отрезок монотонности, затем пытается генерировать значение на выбранном промежутке.

Тип `edsrm_2rng_cfg_t` описывает конфигурацию для инициализации алгоритма. Содержит функцию подбора параметра `prob_eq`, плотность распределения `pd`, промежуток распределения `a` и `b`, экстремум функции `extremum`, размер сетки справа и слева `rsize` и `lsize`.

Тип `edsrm_2rng_t` описывает полную информацию для работы метода.
Функция `edsrm_2rng_generate` генерирует точку.
Функция `edsrm_2rng_create` инициализирует алгоритм.
Функция `edsrm_2rng_free` отчищает память.

Таким образом использование алгоритма выглядит следующим образом:
``` c 
double pd(double u) { return cos(u) + 2 } // Тестовое распределение

// Инициализируем датчик
multiplicative_rand_gen_t gen = multiplicative_rand_gen_create();
uniform_callable_t uc = {
    .gen = multiplicative_rand_gen_generate,
    .arg = &gen
};

// Инициализируем алгоритм для распределения
edsrm_2rng_t cache;
edsrm_2rng_cfg_t cfg = {
    .prob_eq = dbd_prob_eq, // Подбор параметра "цифра за цифрой"
    .pd = pd, // Тестовое распределение
    .a = 0, 
    .b = 2 * pi, // Промежуток 0 < u < 2pi
    .extremum = pi, // Экстремум функции pi
    .lsize = 330, // Точность сетки на интервале (0, pi)
    .rsize = 330  // Точность сетки на интервале (pi, 2pi)
};
if (!edsrm_2rng_create(&edsrm.cache, &cfg)) {
    printf("Не удалось инициализировать алгоритм\n");
    exit(1);
}
// Используем алгоритм
double res = edsrm_2rng_generate(&cache, &uc); // Генерируем число
// .........

// Очищаем память
edsrm_2rng_free(&cache);
```