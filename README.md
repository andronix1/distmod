# Компиляция библиотеки
Откройте терминал в директории библиотеки и соберите её
``` bash
make
```
После этого в этой директории появится библиотека `libdistmod.a`. Для сборки и запуска примеров вместе с библиотекой выполните
``` bash
make examples
```
# Функции библиотеки
Для использования библиотеки подключите её к проекту(например, с помощью аргумента `libdistmod.a` для GCC). Также подключите заголовочный файл библиотеки:
``` c 
#include <distmod.h>
```
## Датчики стандартных псевдослучайных чисел
Функция генерации случайного значения принимает `void*` как аргумент и возвращает `double`. Описывается типом `uniform_t`. 
Для более простого обращения к датчику можно воспользоваться типом `gen_callable_t`
``` c 
gen_callable_t gc = {
    .gen = <...>, // Функция генератоции стандартных случайных чисел(uniform_t)
    .arg = <...>  // Аргумент для функции gen
};
gen_call(&gc);
```
### Вихрь Мерсенна(Mercene Twister)
``` c
mt19937_t mtrd; // Создаём датчик
mt19937_64_init(&mtrd, clock()); // Инициализируем датчик с сидом clock()
double val = mt19937_64_generate(&mtrd); // Генерируем случайное значение
mt19937_64_free(&mtrd); // Очищаем датчик из памяти после того, как все нужные значения получены
```
### Мультипликативный генератор метода вычетов
``` c
multiplicative_rand_gen_t mrd;
multiplicative_rand_gen_init(&mrd); // Создаём датчик
double val = multiplicative_rand_gen_generate(&mrd); // Генерируем случайное значение
```
## Подбор параметра
Тип `prob_eq_overflow_t` описывает функцию, принимающую как аргумент подбираемое значение и любую дополнительную информацию, нужную для алгритма подбора параметра. Возвращает `false`, если значение слишком маленькое, иначе - `true`;
Функция подбора параметра принимает `double*` - ссылку на результат с начальным значением, функцию `prob_eq_overflow_t` и аргумент с дополнительной информацией для предыдущего аргумента. Описывается типом `prob_eq_t`.
### Digit By Digit(DBD)
Реализация `prob_eq_t`. Значение подбирается цифра за цифрой. Функция - `dbd_prob_eq`.
## Экономичный алгоритм двустороннего метода исключения(EDSRM)
Описание алгоритма можете найти по ссылке: http://edsrm.andronix1.ru/docs/edsrm-method-description.pdf
### Монотонные плотности распределения на отрезке(mnt)
Тип `edsrm_mnt_cache_segment_t` описывает столбик сетки. Содержит значение мажоранты, миноранты, и краёв столбика по оси `u`.
Тип `edsrm_mnt_pd_info_t` описывает информацию для построения сетки. То есть плотность распределения `pd`, интервал плотности(`a` и `b`) и количество стобиков в сетке `size`.
Тип `edsrm_mnt_cfg_t` описывает полную конфигурацию для инициализации метода. То есть ссылку на информацию для построения сетки(`pd_info` с типом `edsrm_mnt_pd_info_t`) и алгоритм подбора параметра с типом `prob_eq` `prob_eq_t`
Тип `edsrm_mnt_t` содержит в себе полную информацию для работы с монотонными плотностями распределения. Инициализируется с помощью `edsrm_mnt_init` или `edsrm_mnt_from_idu`.

Функция `edsrm_mnt_is_cache_overflow` - функция "переполнения" с типом `prob_eq_overflow_t`
Функция `edsrm_mnt_from_idu` позволяет инициализировать `edsrm_mnt_t` по ссылке с указанием ширины самого высокого столбика и информации для построения сетки.
Функция `edsrm_mnt_init` - обертка над функцией `edsrm_mnt_from_idu` и позволяет инициализировать `edsrm_mnt_t` по ссылке с помощью полную конфигурацию для инициализации метода. Возвращает результат инициализации - `true` / `false`. Сначала идёт подбор параметра, затем он передаётся в `edsrm_mnt_from_idu`
Функция `edsrm_mnt_free` Нужна для отчистки данных метода из памяти. Её надо вызвать если методом больше пользоваться не будут чтобы избежать утечек памяти.
Функция `edsrm_mnt_try_generate` разыгрывает одну точку под мажорантой и если она попала под `f(u)`(см полное описание алгоритма), то результат записывается в переданную по ссылке переменную и возвражает `true`, иначе - `false` без изменения переменной.
Функция `edsrm_mnt_generate` является обёрткой над функцией `edsrm_mnt_try_generate`. Она пытается сгенерировать точку до тех пор, пока не получится и возвращает значение.

Таким образом использование алгоритма выглядит следующим образом:
``` c 
// Инициализируем датчик
multiplicative_rand_gen_t gen;
multiplicative_rand_gen_init(&gen);
uniform_callable_t uc = {
    .gen = multiplicative_rand_gen_generate,
    .arg = &gen
};

// Инициализируем алгоритм
edsrm_mnt_pd_info_t info = {
    .a = 0,
    .b = pi, 
    .pd = cos, // f(u)=cos(u); 0 < u < pi
    .size = 330 // Размер сетки
};
edsrm_mnt_t cache;
edsrm_mnt_cfg_t cfg = {
    .pd_info = &info,
    .prob_eq = dbd_prob_eq // Подбор параметра "цифра за цифрой"
};
if (!edsrm_mnt_init(&cache, &cfg)) {
    printf("Не удалось инициализировать алгоритм\n");
    exit(1);
}
// Используем алгоритм
double res = edsrm_mnt_generate(&cache, &uc); // Генерируем число
// .........

// Очищаем память
edsrm_mnt_free(&cache);
```
### Плотности с двумы отрезками монотонности(2rng)
Является обёрткой над `edsrm_mnt_t`. Алгоритм разбивает плотность на 2 отрезка монотонности и сначала выбирает отрезок монотонности, затем пытается генерировать значение на выбранном промежутке.

Тип `edsrm_2rng_cfg_t` описывает конфигурацию для инициализации алгоритма. Содержит функцию подбора параметра `prob_eq`, плотность распределения `pd`, промежуток распределения `a` и `b`, экстремум функции `extremum`, размер сетки справа и слева `rsize` и `lsize`.

Тип `edsrm_2rng_t` описывает полную информацию для работы метода.
Функция `edsrm_2rng_generate` генерирует точку.
Функция `edsrm_2rng_init` инициализирует алгоритм.
Функция `edsrm_2rng_free` отчищает память.

Таким образом использование алгоритма выглядит следующим образом:
``` c 
double pd(double u) { return cos(u) + 2 } // Тестовое распределение

// Инициализируем датчик
multiplicative_rand_gen_t gen;
multiplicative_rand_gen_init(&gen);
uniform_callable_t uc = {
    .gen = multiplicative_rand_gen_generate,
    .arg = &gen
};

// Инициализируем алгоритм для распределения
edsrm_2rng_t cache;
edsrm_2rng_cfg_t cfg = {
    .prob_eq = ..., // Подбор параметра "цифра за цифрой"
    .pd = ..., // Тестовое распределение
    .a = ..., // Начало интервала
    .b = ..., // Конец интервала
    .extremum = ..., // Экстремум функции
    .lsize = ..., // Точность сетки на интервале (a, extremum)
    .rsize = ...  // Точность сетки на интервале (extremum, b)
};
if (!edsrm_2rng_init(&edsrm.cache, &cfg)) {
    printf("Не удалось инициализировать алгоритм\n");
    exit(1);
}
// Используем алгоритм
double res = edsrm_2rng_generate(&cache, &uc); // Генерируем число
// .........

// Очищаем память
edsrm_2rng_free(&cache);
```
## Метод Зиккурат
Данный метод работает похожим образом, но требует обратную плотность распределения для инициализации
``` c 
// Инициализируем датчик
multiplicative_rand_gen_t gen;
multiplicative_rand_gen_init(&gen);
uniform_callable_t uc = {
    .gen = multiplicative_rand_gen_generate,
    .arg = &gen
};

// Инициализируем алгоритм для распределения
ziggurat_mnt_t cache;
ziggurat_mnt_cfg_t cfg = {
    .prob_eq = dbd_prob_eq, // Метод уравнивания ветоятностей
    .ipd = ..., // Обратная плотность распределения
    .pd = ..., // Плотность распределения
    .start = ..., // Начало интервала
    .end = ..., // Конец интервала
    .size = ..., // Размер сетки
    .use_ipd_for_gen = ... // Использовать обратную плотность распределения при генерации или плотность распределения
};
if (!ziggurat_mnt_init(&cache, &cfg)) {
    printf("Не удалось инициализировать алгоритм\n");
    exit(1);
}
// Используем алгоритм
double res = ziggurat_mnt_generate(&cache, &uc); // Генерируем число
// .........

// Очищаем память
ziggurat_mnt_free(&cache);
```
## Оптимизация
В данном разделе представлены возможности к оптимизации библиотеки путем уменьшения её универсальности. Эти оптимизации могут чуть изменить способ работы с библиотекой! Флаги оптимизации можно добавить в начало файла distmod.h
### Зиккурат
Метод Зиккурат ет быть такой же универсальный, как и Двусторонний метод ислючения, но эта универсальность может плохо отразиться на производительности. Для уменьшения средней скорости обращения к алгоримту вы можете изменить следующую конфигурацию при компиляции библиотеки
``` c
// Для распределений, "прилегающих" к оси Ou
// Если функция не равна нулю в одном из концов промежутка монотонности, то метод не сможет инициализироваться
#define DISTMOD_ZIGGURAT_DISABLE_BOTTOM_OFFSET

// Для определения использования обратной плотности распределениия или плотности распределения на этапе компиляции
#define DISTMOD_ZIGGURAT_DISABLE_DYNAMIC_USE_IPD
#define DISTMOD_ZIGGURAT_USE_IPD true

// Для определения типа монотонности плотности на этапе компиляции
// Если тип монотонности не соответствует указанному, то метод не сможет инициализироваться
#define DISTMOD_ZIGGURAT_DISABLE_DYNAMIC_DIRECTION
#define DISTMOD_ZIGGURAT_IS_RIGHT false
```

### Генератор случайных чисел
``` c
// Если хотите использовать статический вызов функции, то можете воспользоваться следующей оптимизацией
#define DISTMOD_DISABLE_DYNAMIC_RAND_GEN
#define DISTMOD_RAND_GEN_EXTERN multiplicative_rand_gen_t mul_rand_gen
#define DISTMOD_RAND_GEN_CALL multiplicative_rand_gen_generate(&mul_rand_gen)
```